#!/usr/bin/python3
# bpkg - A universal package manager for blendOS.
# DO NOT TOUCH ANY LINE STARTING WITH --8<-- ! THESE DENOTE EMBEDDABLE SECTIONS!

import os
import sys
import yaml
import subprocess
import errno

version = "0.2.0pre"

# define console colors to simplify colored strings
class colors:
    reset = '\033[0m'
    bold = '\033[01m'
    red = '\033[31m'
    cyan = '\033[36m'
    yellow = '\033[33m'
    white = '\033[39m'

c = colors()

# function with equivalent functionality to the unix command "mkdir -p"
def mkdir_p(newdir):
    try: os.makedirs(newdir)
    except OSError as err:
        # Reraise the error unless it's about an already existing directory 
        if err.errno != errno.EEXIST or not os.path.isdir(newdir): 
            raise

# list all containers on the system, even ones that aren't in your bpkg config file
# --8<-- [start:list]
def list_containers():
    print(c.bold + c.cyan + ">> i: " + c.white + "please wait, loading container list" + c.reset)

    # check container name
    container_names_out = subprocess.check_output(['podman', 'ps', '-a', '--no-trunc', '--size', '--format', '{{.Names}}'])
    # check container image url
    container_images_out = subprocess.check_output(['podman', 'ps', '-a', '--no-trunc', '--size', '--format', '{{.Image}}'])

    # decode outputs to utf-8
    container_names_decoded = container_names_out.decode("utf-8") 
    container_images_decoded = container_images_out.decode("utf-8") 

    # split the resulting strings into individual container names and image urls
    container_names = container_names_decoded.split('\n')
    container_images = container_images_decoded.split('\n')

    # print them in a readable format recursively on the screen
    for i in range(len(container_names) - 1):
        print(container_names[i] + " - " + container_images[i])
# --8<-- [end:list]
# automatically rewrite the config file, recommended to run this after adding/removing containers from the system
# --8<-- [start:overwrite]
def overwrite_config():
    # check container name
    container_names_out = subprocess.check_output(['podman', 'ps', '-a', '--no-trunc', '--size', '--format', '{{.Names}}'])
    # check container image url
    container_images_out = subprocess.check_output(['podman', 'ps', '-a', '--no-trunc', '--size', '--format', '{{.Image}}'])

    # decode outputs to utf-8
    container_names_decoded = container_names_out.decode("utf-8") 
    container_images_decoded = container_images_out.decode("utf-8") 

    # split the resulting strings into individual container names and image urls
    container_names = container_names_decoded.split('\n')
    container_images = container_images_decoded.split('\n')

    # check if the name and image url split arrays are empty
    if len(container_names) == 0:
        print(c.bold + c.red + ">> e: " + c.white + "no containers found, create some containers first" + c.reset)
        print(c.bold + c.red + ">> e: " + c.white + "no changes will be made" + c.reset)
        sys.exit(-2)
    else:
        # find your .config folder and define it into a variable
        confdir = os.path.expanduser('~') + "/.config/"
        # define the full location including the config file filename
        confloc = confdir + "bpkg.yaml"
        # create the required folders if they are missing
        mkdir_p(confdir)
        # create a blank config file and open it
        conf = open(confloc, "w")
        # add comments to the top of the file
        conf.write("# bpkg config file\n# Auto-generated by bpkg ")
        conf.write(version)
        # define the containers: group in yaml
        conf.write("\n\ncontainers:\n")

    # recursively add all containers into the config file based on their name and image url
    for i in range(len(container_names) - 1):
        if container_images[i] == "quay.io/toolbx/arch-toolbox:latest":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("arch\n")
        elif container_images[i] == "quay.io/toolbx/ubuntu-toolbox:22.04":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("ubuntu-22.04\n")
        elif container_images[i] == "docker.io/library/ubuntu:23.04":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("ubuntu-23.04\n")
        elif container_images[i] == "quay.io/toolbx/ubuntu-toolbox:24.04":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("ubuntu-24.04-lts\n")
        elif container_images[i] == "registry.fedoraproject.org/fedora-toolbox:42":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("fedora-42\n")        
        elif container_images[i] == "registry.fedoraproject.org/fedora-toolbox:39":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("fedora-39\n")
        elif container_images[i] == "quay.io/almalinux/almalinux:9":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("almalinux-9\n")
        elif container_images[i] == "registry.getcryst.al/crystal/misc/docker:latest":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("crystal-linux\n")
        elif container_images[i] == "docker.io/library/debian:latest" or container_images[i] == "quay.io/toolbx-images/debian-toolbox:testing":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("debian\n")
        elif container_images[i] == "docker.io/kalilinux/kali-rolling:latest":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("kali-linux\n")
        elif container_images[i] == "docker.io/library/neurodebian:nd120":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("neurodebian-bookworm\n")
        elif container_images[i] == "docker.io/rockylinux/rockylinux:9":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("rocky-linux\n")
        elif container_images[i] == "quay.io/toolbx-images/centos-toolbox:latest":
            conf.write("  - name: ")
            conf.write(container_names[i])
            conf.write("\n    distro: ")
            conf.write("centos\n")
        else:
            # if the distro is not recongnized by bpkg, skip it (you should update bpkg in that case)
            print(c.bold + c.yellow + ">> w: " + c.white + "invalid distro for container \"" + container_names[i] + "\"" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "bpkg is most likely out of date or it hasn't been updated for a new container distro yet" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "skipping distro \"" + container_names[i] + "\"" + c.reset)

    # write the value that allows or disallows updating flatpaks
    conf.write("\nupdate_flatpak: true\n")

    # close the file
    conf.close()
# --8<-- [end:overwrite]
# package installation
# --8<-- [start:install]
def pkginstall(package):
    # define .config folder location and full config file path
    confdir = os.path.expanduser('~') + "/.config/"
    confloc = confdir + "bpkg.yaml"

    # open the config file for reading
    conf = open(confloc, "r")
    # open the file using the pyyaml library for parsing
    yamlconf = yaml.safe_load(conf)

    # recursively check all containers in the config file for which distro they are and use the correct command to
    # check if the container's repos contain the desired package and if they do install it
    for i in range(len(yamlconf["containers"])):
        if (
            yamlconf["containers"][i]["distro"] == "arch" or 
            yamlconf["containers"][i]["distro"] == "crystal-linux"
        ):

            print(c.bold + c.cyan + ">> i: " + c.white + "checking for package \"" + package + "\" in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            pkgcheck = subprocess.run(["sudo", "pacman." + yamlconf["containers"][i]["name"], "-Si", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" found in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
                pkgcheck = subprocess.run(["sudo", "pacman." + yamlconf["containers"][i]["name"], "-S", "--needed", package])
                return pkgcheck.returncode


        elif (
            yamlconf["containers"][i]["distro"] == "ubuntu-22.04" or 
            yamlconf["containers"][i]["distro"] == "ubuntu-24.04-lts" or 
            yamlconf["containers"][i]["distro"] == "debian" or 
            yamlconf["containers"][i]["distro"] == "neurodebian-bookworm" or
            yamlconf["containers"][i]["distro"] == "kali-linux"
            ):

            print(c.bold + c.cyan + ">> i: " + c.white + "checking for package \"" + package + "\" in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            pkgcheck = subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "show", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" found in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
                subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "update"])
                pkgcheck = subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "install", package])
                return pkgcheck.returncode

        elif (
            yamlconf["containers"][i]["distro"] == "fedora-42" or 
            yamlconf["containers"][i]["distro"] == "almalinux-9" or
            yamlconf["containers"][i]["distro"] == "fedora-39" or
            yamlconf["containers"][i]["distro"] == "centos" or
            yamlconf["containers"][i]["distro"] == "rocky-linux"
            ):

            print(c.bold + c.cyan + ">> i: " + c.white + "checking for package \"" + package + "\" in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            pkgcheck = subprocess.run(["sudo", "dnf." + yamlconf["containers"][i]["name"], "info", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" found in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
                pkgcheck = subprocess.run(["sudo", "dnf." + yamlconf["containers"][i]["name"], "install", package, "--refresh"])
                return pkgcheck.returncode

        else:
            # in case the config file has an unrecognized distro by bpkg, skip it
            # this is usually due to errors in the config file since the config file autogeneration should not cause this
            print(c.bold + c.yellow + ">> w: " + c.white + "invalid distro for container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "bpkg is most likely out of date or it hasn't been updated for a new container distro yet" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "skipping distro \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
    
    # if the package isn't found in any containers, display an error
    print(c.bold + c.red + ">> e: " + c.white + "package \"" + package + "\" not found in your containers" + c.reset)
# --8<-- [end:install]
# Package removal
# --8<-- [start:remove]
def pkgremove(package):
    # define .config folder and full config file paths
    confdir = os.path.expanduser('~') + "/.config/"
    confloc = confdir + "bpkg.yaml"

    # open config file for reading
    conf = open(confloc, "r")
    # open the config file using pyyaml for parsing
    yamlconf = yaml.safe_load(conf)

    # recursively check which container from the config file has the package you want to remove installed, and if it does remove it
    for i in range(len(yamlconf["containers"])):
        if (
            yamlconf["containers"][i]["distro"] == "arch" or 
            yamlconf["containers"][i]["distro"] == "crystal-linux"
        ):

            print(c.bold + c.cyan + ">> i: " + c.white + "checking if package \"" + package + "\" in container \"" + yamlconf["containers"][i]["name"] + "\" is installed" + c.reset)
            pkgcheck = subprocess.run(["sudo", "pacman." + yamlconf["containers"][i]["name"], "-Q", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" is installed in container \"" + yamlconf["containers"][i]["name"] + "\", removing" + c.reset)
                pkgcheck = subprocess.run(["sudo", "pacman." + yamlconf["containers"][i]["name"], "-R", package])
                return pkgcheck.returncode


        elif (
            yamlconf["containers"][i]["distro"] == "ubuntu-22.04" or 
            yamlconf["containers"][i]["distro"] == "ubuntu-24.04-lts" or 
            yamlconf["containers"][i]["distro"] == "debian" or 
            yamlconf["containers"][i]["distro"] == "neurodebian-bookworm" or
            yamlconf["containers"][i]["distro"] == "kali-linux"
            ):

            print(c.bold + c.cyan + ">> i: " + c.white + "checking if package \"" + package + "\" in container \"" + yamlconf["containers"][i]["name"] + "\" is installed" + c.reset)
            is_pkg_installed_out = subprocess.check_output(["sudo", "apt." + yamlconf["containers"][i]["name"], "list", "-qq", package, "--installed"])
            is_pkg_installed_decoded = is_pkg_installed_out.decode("utf-8") 

            if is_pkg_installed_decoded != "":
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" is installed in container \"" + yamlconf["containers"][i]["name"] + "\", removing" + c.reset)
                subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "update"])
                pkgcheck = subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "remove", package])
                return pkgcheck.returncode

        elif (
            yamlconf["containers"][i]["distro"] == "fedora-42" or 
            yamlconf["containers"][i]["distro"] == "almalinux-9" or
            yamlconf["containers"][i]["distro"] == "fedora-39" or
            yamlconf["containers"][i]["distro"] == "centos" or
            yamlconf["containers"][i]["distro"] == "rocky-linux"
            ):

            print(c.bold + c.cyan + ">> i: " + c.white + "checking if package \"" + package + "\" in container \"" + yamlconf["containers"][i]["name"] + "\" is installed" + c.reset)
            pkgcheck = subprocess.run(["sudo", "dnf." + yamlconf["containers"][i]["name"], "list", "installed", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" is installed in container \"" + yamlconf["containers"][i]["name"] + "\", removing" + c.reset)
                pkgcheck = subprocess.run(["sudo", "dnf." + yamlconf["containers"][i]["name"], "remove", package])
                return pkgcheck.returncode

        else:
            # if the config file contains an invalid distro, skip it
            # this usually happens because of an error in the config file, config file autogen accounts for this and shouldn't cause it
            print(c.bold + c.yellow + ">> w: " + c.white + "invalid distro for container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "bpkg is most likely out of date or it hasn't been updated for a new container distro yet" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "skipping distro \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
    
    # display an error if the specified package isn't installed in any of the containers defined in the config
    print(c.bold + c.red + ">> e: " + c.white + "package \"" + package + "\" is not installed in any of your containers" + c.reset)
# --8<-- [end:remove]
# container repository index and package updating
# --8<-- [start:update]
def pkgupdate():
    # define .config and config file paths
    confdir = os.path.expanduser('~') + "/.config/"
    confloc = confdir + "bpkg.yaml"

    # open the config file for reading
    conf = open(confloc, "r")
    # open the config file using pyyaml for parsing
    yamlconf = yaml.safe_load(conf)

    # recurisvely check what distro a config file defined container is, and update its repo index and packages
    for i in range(len(yamlconf["containers"])):
        if (
            yamlconf["containers"][i]["distro"] == "arch" or 
            yamlconf["containers"][i]["distro"] == "crystal-linux"
        ):

            print(c.bold + c.cyan + ">> i: " + c.white + "updating container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            subprocess.run(["sudo", "pacman." + yamlconf["containers"][i]["name"], "-Syu", "--noconfirm"])

        elif (
            yamlconf["containers"][i]["distro"] == "ubuntu-22.04" or 
            yamlconf["containers"][i]["distro"] == "ubuntu-24.04-lts" or 
            yamlconf["containers"][i]["distro"] == "debian" or 
            yamlconf["containers"][i]["distro"] == "neurodebian-bookworm" or
            yamlconf["containers"][i]["distro"] == "kali-linux"
            ):

            print(c.bold + c.cyan + ">> i: " + c.white + "updating container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "update"])
            subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "upgrade", "-y"])

        elif (
            yamlconf["containers"][i]["distro"] == "fedora-42" or 
            yamlconf["containers"][i]["distro"] == "almalinux-9" or
            yamlconf["containers"][i]["distro"] == "fedora-39" or
            yamlconf["containers"][i]["distro"] == "centos" or
            yamlconf["containers"][i]["distro"] == "rocky-linux"
            ):

            print(c.bold + c.cyan + ">> i: " + c.white + "updating container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            subprocess.run(["sudo", "dnf." + yamlconf["containers"][i]["name"], "update", "-y", "--refresh"])

        else:
            # if the config file contains an invalid distro, skip it
            # this usually happens because of an error in the config file, config file autogen accounts for this and shouldn't cause it
            print(c.bold + c.yellow + ">> w: " + c.white + "invalid distro for container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "bpkg is most likely out of date or it hasn't been updated for a new container distro yet" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "skipping distro \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
    
    # check if update_flatpak value in config file is defined as true, and if it is update the flatpak packages
    if yamlconf["update_flatpak"] == True:
        print(c.bold + c.cyan + ">> i: " + c.white + "updating flatpak" + c.reset)
        subprocess.run(["flatpak", "update", "-y"])
# --8<-- [end:update]
# package searching in containers
# --8<-- [start:search]
def pkgsearch(package):
    # define .config folder and config file paths
    confdir = os.path.expanduser('~') + "/.config/"
    confloc = confdir + "bpkg.yaml"

    # open config file for reading
    conf = open(confloc, "r")
    # open config file using pyyaml for parsing
    yamlconf = yaml.safe_load(conf)

    # define the variable indicating if the package has been found in a repository of a container
    isfound = False

    # recursively check if the package is available in any of the containers, and if it is display a message and define the isFound variable as True
    for i in range(len(yamlconf["containers"])):
        if (
            yamlconf["containers"][i]["distro"] == "arch" or 
            yamlconf["containers"][i]["distro"] == "crystal-linux"
        ):

            pkgcheck = subprocess.run(["sudo", "pacman." + yamlconf["containers"][i]["name"], "-Si", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" found in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
                isfound = True


        elif (
            yamlconf["containers"][i]["distro"] == "ubuntu-24.04-lts" or 
            yamlconf["containers"][i]["distro"] == "ubuntu-23.04" or 
            yamlconf["containers"][i]["distro"] == "debian" or 
            yamlconf["containers"][i]["distro"] == "neurodebian-bookworm" or
            yamlconf["containers"][i]["distro"] == "kali-linux"
            ):

            pkgcheck = subprocess.run(["sudo", "apt." + yamlconf["containers"][i]["name"], "show", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" found in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
                isfound = True

        elif (
            yamlconf["containers"][i]["distro"] == "fedora-42" or 
            yamlconf["containers"][i]["distro"] == "almalinux-9" or
            yamlconf["containers"][i]["distro"] == "fedora-39" or
            yamlconf["containers"][i]["distro"] == "centos" or
            yamlconf["containers"][i]["distro"] == "rocky-linux"
            ):

            pkgcheck = subprocess.run(["sudo", "dnf." + yamlconf["containers"][i]["name"], "info", package], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL)

            if pkgcheck.returncode == 0:
                print(c.bold + c.cyan + ">> i: " + c.white + "package \"" + package + "\" found in container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
                isfound = True

        else:

            print(c.bold + c.yellow + ">> w: " + c.white + "invalid distro for container \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "bpkg is most likely out of date or it hasn't been updated for a new container distro yet" + c.reset)
            print(c.bold + c.yellow + ">> w: " + c.white + "skipping distro \"" + yamlconf["containers"][i]["name"] + "\"" + c.reset)

    # if the isFound variable hasn't been changed to True during the loop, that means the package hasn't been found in any of the defined containers
    # in that case print an error message
    if isfound == False:
        print(c.bold + c.red + ">> e: " + c.white + "package \"" + package + "\" not found in your containers" + c.reset)
# --8<-- [end:search]
# display the usage
# --8<-- [start:help]
def usage():
    # not much to say about this function, just prints some strings to the screen :)
    print("Usage:")
    print("bpkg install <package> - Install a package")
    print("bpkg remove <package> - Remove a package")
    print("bpkg update - Update repositories and upgrade packages")
    print("bpkg search <package> - Display which repositories contain the desired package")
    print("bpkg list-containers - List all containers on your system, even the ones not in the config file for bpkg")
    print("bpkg overwrite-config - Overwrites the config file with an autogenerated one")
    print("bpkg help or bpkg usage or bpkg about - Display this message")
    print("You can also input the name of one of your containers\nas the final argument to do operations only to that specific container.")
    print("For more documentation visit https://docs.blendos.co/docs/utilities/bpkg/\n")
    print("About:")
    print("bpkg " + version)
    print("Designed for blendOS\n")
    print("Contributors:")
    print("SvGaming - bpkg lead developer")
    print("Asterisk - bpkg documentation")
# --8<-- [end:help]
# the main function, the program starts executing here
def main():
    # check if bpkg is running as a root user
    if os.geteuid() == 0:
        # if it is exit bpkg, as containers must be handled at a user level
        print(c.bold + c.red + ">> e: " + c.white + "must be run as a non-root user, root permissons will be requested if required" + c.reset)
        sys.exit(-1)

    # define .config folder and config file locations
    confdir = os.path.expanduser('~') + "/.config/"
    confloc = confdir + "bpkg.yaml"

    # if the config file exists, skip this code
    if os.path.exists(confloc):
        pass
    # if it doesn't, generate it using the overwrite_config() function
    else:
        print(c.bold + c.cyan + ">> i: " + c.white + "The bpkg config file located at \"" + confloc + "\" seems to be missing. Generating config..." + c.reset)
        overwrite_config()
        print(c.bold + c.cyan + ">> i: " + c.white + "done, your new config file is located at \"" + confloc + "\"" + c.reset)
        print(c.bold + c.cyan + ">> i: " + c.white + "a config file editing guide is available at https://docs.blendos.co/docs/utilities/bpkg#configuration" + c.reset)

    # if bpkg is launched with an insufficient number of arguments, exit bpkg
    if len(sys.argv) < 2:
        print(c.bold + c.red + ">> e: " + c.white + "insufficient arguments" + c.reset)
        usage()
        sys.exit(1)
    
    # based on the command line parameter select the correct function and run it
    # 2 argument requiring parameters
    if sys.argv[1] == "update":
        pkgupdate()
    elif sys.argv[1] == "search":
        for i in range(2, len(sys.argv)):
            pkgsearch(sys.argv[i])
    elif sys.argv[1] == "help" or sys.argv[1] == "usage" or sys.argv[1] == "about":
        usage()
    elif sys.argv[1] == "overwrite-config":
        print(c.bold + c.cyan + ">> i: " + c.white + "overwriting old config file with an autogenerated one" + c.reset)
        overwrite_config()
        print(c.bold + c.cyan + ">> i: " + c.white + "done, your new config file is located at \"" + confloc + "\"" + c.reset)
        print(c.bold + c.cyan + ">> i: " + c.white + "a config file editing guide is available at https://docs.blendos.co/docs/utilities/bpkg#configuration" + c.reset)
    elif sys.argv[1] == "list-containers":
        list_containers()
    # if none of those parameters are selected, move onto the 3 argument requiring parameters
    else: 
        # if the running command doesn't contain 3 arguments, exit bpkg
        if len(sys.argv) < 3:
            print(c.bold + c.red + ">> e: " + c.white + "insufficient arguments for this operation or invalid operation" + c.reset)
            usage()
            sys.exit(1)
        if sys.argv[1] == "install":
            for i in range(2, len(sys.argv)):
                exitcode = pkginstall(sys.argv[i])
            sys.exit(exitcode)
        elif sys.argv[1] == "remove":
            for i in range(2, len(sys.argv)):
                exitcode = pkgremove(sys.argv[i])
            sys.exit(exitcode)
        # exit if the parameter still hasn't been found
        else:
            print(c.bold + c.red + ">> e: " + c.white + "invalid operation" + c.reset)
            usage()
            sys.exit(1)
    
# start the main() function on program startup if bpkg hasn't been imported as a library into another python script
if __name__ == '__main__':
    main()
